import pyodbc
import openai
# Mail imports
import os.path
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

#SEND MESSAGE
#--------------------
import base64
import time

# Send email function
def send_email(sender_email, recipient_email, subject, body):
    """
    Sends an email using the Gmail API.

    Args:
        sender_email (str): Email address of the sender.
        recipient_email (str): Email address of the recipient.
        subject (str): Subject of the email.
        body (str): Body content of the email.
    """
    message = create_message(sender_email, recipient_email, subject, body)
    try:
        encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode("utf-8")
        service.users().messages().send(userId='me', body={'raw': encoded_message}).execute()
        print("Email sent successfully!")
    except Exception as e:
        print("An error occurred:", str(e))

def create_message(sender_email, recipient_email, subject, body):
    """
    Creates an email message.

    Args:
        sender_email (str): Email address of the sender.
        recipient_email (str): Email address of the recipient.
        subject (str): Subject of the email.
        body (str): Body content of the email.

    Returns:
        email.mime.text.MIMEText: Email message object.
    """
    from email.mime.text import MIMEText
    message = MIMEText(body)
    message['to'] = recipient_email
    message['from'] = sender_email
    message['subject'] = subject
    return message

def execute_mail():
    """
    Executes Gmail API requests to retrieve unread messages.

    Returns:
        list: List of features extracted from the email (sender, snippet, subject).
            Returns "None" if there are no new unread messages.
    """
    try:
        results = service.users().messages().list(userId='me', labelIds=['INBOX'], q='is:unread', maxResults=1).execute()
        messages = results.get('messages', [])

        if not messages:
            print('No new unread messages.')
            return "None"
        
        features = []
        message = messages[0]
        msg = service.users().messages().get(userId='me', id=message['id'], format='full').execute()
        headers = msg['payload']['headers']
        subject = [header['value'] for header in headers if header['name'] == 'Subject']
        sender = [header['value'] for header in headers if header['name'] == 'From']
        
        # Extract the email address from the sender field
        start_index = sender[0].find('<')
        end_index = sender[0].find('>', start_index)
        if start_index != -1 and end_index != -1:
            email_address = sender[0][start_index + 1: end_index]
            features.append(email_address)
        
        features.append(msg["snippet"])
        features.append(subject[0])
        
        if(subject[0].lower() == "soru" or subject[0].lower() == "re: soru" or subject[0] == "Re: Thank you for your email"):
            # Mark the message as read
            service.users().messages().modify(userId='me', id=message['id'], body={'removeLabelIds': ['UNREAD']}).execute()
        
        return features
        
    except HttpError as error:
        print(f'An error occurred: {error}')

def preprocess_input(input_text):
    """
    Preprocesses the user input text.

    Args:
        input_text (str): User input text.

    Returns:
        str: Preprocessed input text.
    """
    # Implement any necessary preprocessing steps here
    preprocessed_text = input_text.lower()  # convert to lowercase
    return preprocessed_text

def ask_chatgpt(question, courses):
    """
    Generates a response from ChatGPT based on the user question.

    Args:
        question (str): User's question.
        courses (list): List of available courses.

    Returns:
        str: Response generated by ChatGPT.
    """
    # Set the ChatGPT model and parameters
    model = 'gpt-3.5-turbo'
    chat_params = {
        'messages': [
            {'role': 'system', 'content': 'You are a user asking about the suitable course.'},
            {'role': 'user', 'content': f'I have a website that sells software courses and I have these courses: {", ".join(courses)}. A client asked me the following question: {question}. Please provide a brief and concise answer. If I do not have the requested course or if the question is not relevant to course suggestions, kindly inform the client that you cannot provide assistance in that matter. The answer should be in Turkish.'}
        ]
    }

    # Send the user question to ChatGPT and get the response
    response = openai.ChatCompletion.create(
        model=model,
        messages=chat_params['messages']
    )

    # Extract the model's reply from the response
    reply = response.choices[0].message.content

    return reply

while True:
    # Set the interval for checking emails (in seconds)
    time.sleep(10)
    
    # Set up your OpenAI API credentials
    openai.api_key = 'YOUR_OPENAI_API_KEY'
    
    # Establish a connection to the database
    conn = pyodbc.connect('DRIVER={SQL Server};SERVER=YOUR_SERVER_NAME;DATABASE=YOUR_DATABASE_NAME;UID=YOUR_USERNAME;PWD=YOUR_PASSWORD')
    
    # Create a cursor object to execute SQL queries
    cursor = conn.cursor()
    
    # Execute a SELECT query to retrieve the data
    cursor.execute("SELECT Title, Description, Information, Skills FROM YOUR_TABLE_NAME")
    
    # Fetch all the rows from the result set
    courses = cursor.fetchall()
    
    # Close the cursor and connection
    cursor.close()
    conn.close()
    
    # If modifying these scopes, delete the file token.json.
    SCOPES = ['https://www.googleapis.com/auth/gmail.readonly', 'https://www.googleapis.com/auth/gmail.modify', 'https://www.googleapis.com/auth/gmail.send']
    
    creds = None
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file('credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    
    service = build('gmail', 'v1', credentials=creds)
    
    mail_parts = execute_mail()
    
    # Example usage
    if mail_parts == "None":
        print("No new questions.")
    elif mail_parts[2].lower() == "soru" or mail_parts[2].lower() == "re: soru" or mail_parts[2] == "Re: Thank you for your email":
        user_input = mail_parts[1]
        user_input = preprocess_input(user_input)
        
        # Example usage
        course_list = []
        for course in courses:
            title = course.CourseName  # Replace with the appropriate column name from your table
            description = course.Description
            skills = course.Skills
            info = course.Information
            course_list.append(f"{title}-{description}-{skills}-{info}")
        
        # Generate a response from ChatGPT based on the user question
        chatgpt_question = user_input
        chatgpt_response = ask_chatgpt(chatgpt_question, course_list)
        print("\n", chatgpt_response)
        
        sender_email = 'YOUR_SENDER_EMAIL'
        recipient_email = mail_parts[0]
        subject = 'Thank you for your email'
        body = chatgpt_response
        
        send_email(sender_email, recipient_email, subject, body)
